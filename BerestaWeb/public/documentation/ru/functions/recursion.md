# Рекурсия

Рекурсия позволяет функции вызывать саму себя, чтобы решать задачу поэтапно, разбивая её на меньшие подзадачи.  
Эта техника полезна для математических вычислений, обхода структур данных и повторяющейся логики, которая естественным образом делится на подпроблемы.

---

## Синтаксис
```beresta
function name(parameter)
{
    if(base_condition)
    {
        return base_result;
    }

    return name(modified_parameter);
}
```

---

## Описание

В BerestaLanguage рекурсивные вызовы работают так же, как и в большинстве процедурных языков.  
Каждый вызов функции создаёт новую область видимости, где локальные переменные независимы от предыдущих вызовов.

Когда достигается оператор `return`, выполнение продолжается с того места, где функция была вызвана.

Чтобы избежать бесконечной рекурсии, необходимо гарантировать, что каждый рекурсивный вызов приближается к базовому случаю, который завершает процесс.

---

## Примеры

Факториал:
```beresta
public function fact(n)
{
    if(n <= 1)
    {
        return 1;
    }

    return n * fact(n - 1);
}

let result = fact(5);
console_print(result); // 120
```

Сумма чисел:
```beresta
function sum_to(n)
{
    if(n <= 0)
    {
        return 0;
    }

    return n + sum_to(n - 1);
}

console_print(sum_to(10)); // 55
```

Пример вложенной рекурсии:
```beresta
function countdown(n)
{
    if(n <= 0)
    {
        console_print("Done!"); // Готово!
        return;
    }

    console_print(n);
    countdown(n - 1);
}

countdown(5);
```

---

## Примечания

- Каждый рекурсивный вызов создаёт новый стек вызовов.  
- Локальные переменные не конфликтуют между уровнями рекурсии.  
- Всегда определяй базовые условия, чтобы избежать бесконечной рекурсии.  
- Глубокая рекурсия может привести к переполнению стека, если интерпретатор не ограничивает глубину вызовов.
