# Массивы

Массивы в BerestaLanguage являются **динамическими**, **гетерогенными** (могут содержать разные типы данных) и **глубоко вложенными** структурами.  
Они — один из основных типов данных языка, обеспечивающий гибкое хранение и удобную итерацию.

---

## Базовое объявление

Массивы записываются в квадратных скобках `[]`.  
Можно инициализировать их значениями или оставить пустыми:

```beresta
let a = [1, 2, 3];
let b = ["apple", "banana", "cherry"];
let c = []; // пустой массив
```

Массивы могут содержать любые типы данных: числа, строки, булевы значения или даже другие массивы:
```beresta
let mixed = [1, "hi", true, [10, 20]];
```

---

## Индексация

Массивы нумеруются с нуля, то есть первый элемент имеет индекс `0`. Доступ к элементам осуществляется через оператор `[]`:
```beresta
let a = [10, 20, 30];
console_print(a[0]); // 10
console_print(a[2]); // 30
```

Если индекс не является целым числом, он автоматически приводится к целому с округлением вниз:
```beresta
console_print(a[1.9]); // рассматривается как a[1]
```

Обращение к индексу за пределами диапазона возвращает пустое значение `(none)`.

---

## Вложенные массивы

Массивы могут содержать другие массивы, и можно использовать цепочку индексов:
```beresta
let a = [1, [2, 3], 4];
console_print(a[1][0]); // 2
```

При присвоении значения во вложенный индекс недостающие промежуточные массивы создаются автоматически:
```beresta
let b = [];
b[2][1][0] = "x";
console_print(b); // [none, none, [none, ["x"]]]
```

---

## Присваивание и расширение

Массивы автоматически увеличиваются при присвоении значений за пределами текущей длины:
```beresta
let a = [1, 2];
a[5] = 99;
console_print(a); // [1, 2, none, none, none, 99]
```

---

## Примеры изменения

Можно напрямую изменять элементы массива:
```beresta
let a = [1, "hi", true];
a[1] = "hello";
a[2] = false;
console_print(a); // [1, "hello", false]
```

Даже вложенные значения можно заменить:
```beresta
a[3][0] = 42;
```

---

## Работа с циклами

Массивы тесно интегрированы с циклом `foreach`:
```beresta
let arr = [10, 20, 30];
foreach(x in arr)
{
    console_print(x);
}
```

`foreach` автоматически обрабатывает вложенные массивы, что делает его удобным для двумерных структур:
```beresta
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

foreach(row in matrix)
{
    foreach(val in row)
    {
        console_print(val);
    }
}
```

---

## Массивы как результат функций

Функции могут возвращать массивы, что позволяет модульно создавать данные:
```beresta
public function make_arr()
{
    return [5, 6, 7];
}

console_print(make_arr()[1]); // 6
```

---

## Динамическое расширение и вычисления

Массивы можно динамически увеличивать внутри циклов:
```beresta
let c = [];
for(let k = 0; k < 3; k = k + 1)
{
    c[k] = k * 10;
}
console_print(c); // [0, 10, 20]
```

Массив автоматически расширяется при присвоении значений с более высоким индексом:
```beresta
c[5] = 50;
console_print(c); // [0, 10, 20, none, none, 50]
```

---

## Использование массивов в условиях

Массивы можно обрабатывать в циклах для суммирования или фильтрации данных:
```beresta
let sum = 0;
let j = 0;
while(j < 3)
{
    sum = sum + c[j];
    j = j + 1;
}
console_print(sum);
```

---

## Примечания

- Массивы в BerestaLanguage — это гибкие контейнеры, схожие с массивами GameMaker, но с улучшенной автоматической инициализацией, вложенностью и поддержкой смешанных типов.
